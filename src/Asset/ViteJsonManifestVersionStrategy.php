<?php

namespace AchttienVijftien\Stud\Asset;

use Symfony\Component\Asset\Exception\AssetNotFoundException;
use Symfony\Component\Asset\Exception\LogicException;
use Symfony\Component\Asset\Exception\RuntimeException;
use Symfony\Component\Asset\VersionStrategy\VersionStrategyInterface;

/**
 * Class ViteJsonManifestVersionStrategy
 *
 * ViteJsonManifestVersionStrategy leverages a JSON manifest file generated by the
 * Vite build tool to determine the versioning and location of assets. This helps
 * in cache-busting and ensuring that the correct asset versions are loaded in
 * production environments.
 *
 * The manifest file should contain a mapping of original asset paths to their
 * corresponding versioned file paths.
 *
 * This class provides a mechanism to read the manifest and resolve paths based on
 * the mappings found in it, enabling easy integration of Vite with PHP-based
 * web applications.
 */
class ViteJsonManifestVersionStrategy implements VersionStrategyInterface {

	/**
	 * Loaded manifest data.
	 *
	 * @var array|null
	 */
	private ?array $manifest_data;

	/**
	 * Class ViteJsonManifestVersionStrategy
	 *
	 * @param string $manifest_path Absolute path to the manifest file.
	 * @param bool $strict_mode Throws an exception for unknown paths.
	 */
	public function __construct(
		private string $manifest_path,
		private ?HttpClientInterface $http_client = null,
		private bool $strict_mode = false,
	) {
		if ( null === $this->http_client && ( $scheme = parse_url( $this->manifest_path, \PHP_URL_SCHEME ) ) && str_starts_with( $scheme, 'http' ) ) {
			throw new LogicException( sprintf( 'The "%s" class needs an HTTP client to use a remote manifest. Try running "composer require symfony/http-client".', self::class ) );
		}
	}

	/**
	 * Gets version.
	 *
	 * @param string $path Path to get.
	 *
	 * @return string
	 */
	public function getVersion( string $path ): string {
		return $this->applyVersion( $path );
	}

	/**
	 * Applies version to the supplied path.
	 *
	 * @param string $path Path to apply version of.
	 *
	 * @return string
	 */
	public function applyVersion( string $path ): string {
		return $this->get_manifest_path( $path ) ?: $path;
	}

	/**
	 * Gets path from manifest data.
	 *
	 * @param string $path Path to get.
	 *
	 * @return string|null
	 */
	public function get_manifest_path( string $path ): ?string {
		$manifest_data = $this->get_manifest_data();

		if ( ! empty( $manifest_data[ $path ]['file'] ) ) {
			return $manifest_data[ $path ]['file'];
		}

		if ( $this->strict_mode ) {
			$message      = sprintf( 'Asset "%s" not found in manifest "%s".', $path, $this->manifest_path );
			$alternatives = $this->findAlternatives( $path, $manifest_data );
			if ( \count( $alternatives ) > 0 ) {
				$message .= sprintf( ' Did you mean one of these? "%s".', implode( '", "', $alternatives ) );
			}

			throw new AssetNotFoundException( $message, $alternatives );
		}

		return null;
	}

	/**
	 * Gets manifest data, loads data from path if not yet present.
	 *
	 * @return array|null
	 */
	private function get_manifest_data(): ?array {
		if ( ! isset( $this->manifest_data ) ) {
			if ( null !== $this->http_client && ( $scheme = parse_url( $this->manifest_path, \PHP_URL_SCHEME ) ) && str_starts_with( $scheme, 'http' ) ) {
				try {
					$this->manifest_data = $this->http_client->request( 'GET', $this->manifest_path,
						[
							'headers' => [ 'accept' => 'application/json' ],
						]
					)->toArray();
				} catch ( DecodingExceptionInterface $e ) {
					throw new RuntimeException( sprintf( 'Error parsing JSON from asset manifest URL "%s".', $this->manifest_path ), 0, $e );
				} catch ( ClientExceptionInterface $e ) {
					throw new RuntimeException( sprintf( 'Error loading JSON from asset manifest URL "%s".', $this->manifest_path ), 0, $e );
				}
			} else {
				if ( ! is_file( $this->manifest_path ) ) {
					throw new RuntimeException( sprintf( 'Asset manifest file "%s" does not exist. Did you forget to build the assets with npm or yarn?', $this->manifest_path ) );
				}

				try {
					$this->manifest_data = json_decode( file_get_contents( $this->manifest_path ), true, flags: \JSON_THROW_ON_ERROR );
				} catch ( \JsonException $e ) {
					throw new RuntimeException( sprintf( 'Error parsing JSON from asset manifest file "%s": ', $this->manifest_path ) . $e->getMessage(), previous: $e );
				}
			}
		}

		return $this->manifest_data;
	}
}
